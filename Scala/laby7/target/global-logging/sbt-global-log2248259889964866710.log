[0m[[0m[0mdebug[0m] [0m[0m> Exec(run, Some(705c48f3-6b47-4bde-9a17-be8932f78d45), Some(CommandSource(console0)))[0m
[0m[[0m[0mdebug[0m] [0m[0mEvaluating tasks: Compile / run[0m
[0m[[0m[0mdebug[0m] [0m[0mRunning task... Cancel: Signal, check cycles: false, forcegc: true[0m
[0m[[0m[0minfo[0m] [0m[0mcompiling 1 Scala source to /home/mati/homelab/Scala/lab07/target/scala-3.3.1/classes ...[0m
[0m[[0m[31merror[0m] [0m[0m[31m[31m-- [E007] Type Mismatch Error: /home/mati/homelab/Scala/lab07/src/main/scala/Zad3.scala:8:82 [0m[0m[0m
[0m[[0m[31merror[0m] [0m[0m[31m8 |[0m  [33mval[0m [36mfinals[0m = letters.map(_.groupMapReduce(_.toLower)(_ => [31m1[0m)(_ + _)).reduce(_ + _)[0m
[0m[[0m[31merror[0m] [0m[0m[31m[31m  |[0m                                                                                  ^[0m[0m
[0m[[0m[31merror[0m] [0m[0m[31m  |[0m                                          Found:    ([1m[31m_$[0m[1m[31m9[0m[1m[31m [0m[1m[31m:[0m[1m[31m [0m[1m[31mMap[0m[1m[31m[[0mChar, Int[1m[31m][0m)[0m
[0m[[0m[31merror[0m] [0m[0m[31m  |[0m                                          Required: (Char, Int)[0m
[0m[[0m[31merror[0m] [0m[0m[31m  |-----------------------------------------------------------------------------[0m[0m
[0m[[0m[31merror[0m] [0m[0m[31m  |[0m Explanation (enabled by `-explain`)[0m
[0m[[0m[31merror[0m] [0m[0m[31m  |- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -[0m[0m
[0m[[0m[31merror[0m] [0m[0m[31m  |[0m[0m
[0m[[0m[31merror[0m] [0m[0m[31m  |[0m Tree: _$9[0m
[0m[[0m[31merror[0m] [0m[0m[31m  |[0m I tried to show that[0m
[0m[[0m[31merror[0m] [0m[0m[31m  |[0m   (_$9 : Map[Char, Int])[0m
[0m[[0m[31merror[0m] [0m[0m[31m  |[0m conforms to[0m
[0m[[0m[31merror[0m] [0m[0m[31m  |[0m   (Char, Int)[0m
[0m[[0m[31merror[0m] [0m[0m[31m  |[0m but the comparison trace ended with `false`:[0m
[0m[[0m[31merror[0m] [0m[0m[31m  |[0m[0m
[0m[[0m[31merror[0m] [0m[0m[31m  |[0m   ==> (_$9 : Map[Char, Int])  <:  (Char, Int)[0m
[0m[[0m[31merror[0m] [0m[0m[31m  |[0m     ==> (_$9 : Map[Char, Int])  <:  (Char, Int)[0m
[0m[[0m[31merror[0m] [0m[0m[31m  |[0m       ==> Map[Char, Int]  <:  (Char, Int) (left is approximated)[0m
[0m[[0m[31merror[0m] [0m[0m[31m  |[0m       <== Map[Char, Int]  <:  (Char, Int) (left is approximated) = false[0m
[0m[[0m[31merror[0m] [0m[0m[31m  |[0m     <== (_$9 : Map[Char, Int])  <:  (Char, Int) = false[0m
[0m[[0m[31merror[0m] [0m[0m[31m  |[0m     ==> Map[Char, Int]  <:  (Char, Int) (left is approximated)[0m
[0m[[0m[31merror[0m] [0m[0m[31m  |[0m       ==> Map[Char, Int]  <:  (Char, Int) (left is approximated)[0m
[0m[[0m[31merror[0m] [0m[0m[31m  |[0m       <== Map[Char, Int]  <:  (Char, Int) (left is approximated) = false[0m
[0m[[0m[31merror[0m] [0m[0m[31m  |[0m     <== Map[Char, Int]  <:  (Char, Int) (left is approximated) = false[0m
[0m[[0m[31merror[0m] [0m[0m[31m  |[0m   <== (_$9 : Map[Char, Int])  <:  (Char, Int) = false[0m
[0m[[0m[31merror[0m] [0m[0m[31m  |[0m[0m
[0m[[0m[31merror[0m] [0m[0m[31m  |[0m The tests were made under a constraint with:[0m
[0m[[0m[31merror[0m] [0m[0m[31m  |[0m  uninstantiated variables: B, V1[0m
[0m[[0m[31merror[0m] [0m[0m[31m  |[0m  constrained types:[0m
[0m[[0m[31merror[0m] [0m[0m[31m  |[0m   [K, B](key: Char => K)(f: Char => B)(reduce: (B, B) => B): Map[K, B],[0m
[0m[[0m[31merror[0m] [0m[0m[31m  |[0m   [B >: Map[Char, Int]](op: (B, B) => B): B,[0m
[0m[[0m[31merror[0m] [0m[0m[31m  |[0m   [B >: Map[Char, Int]](op: (B, B) => B): B,[0m
[0m[[0m[31merror[0m] [0m[0m[31m  |[0m   [V1 >: Int][0m
[0m[[0m[31merror[0m] [0m[0m[31m  |[0m     (elem1: (Char, V1), elem2: (Char, V1), elems: (Char, V1)*): Map[Char, V1],[0m
[0m[[0m[31merror[0m] [0m[0m[31m  |[0m   [V1 >: Int](kv: (Char, V1)): Map[Char, V1][0m
[0m[[0m[31merror[0m] [0m[0m[31m  |[0m  bounds:[0m
[0m[[0m[31merror[0m] [0m[0m[31m  |[0m      K := Char[0m
[0m[[0m[31merror[0m] [0m[0m[31m  |[0m      B := Int[0m
[0m[[0m[31merror[0m] [0m[0m[31m  |[0m      B >: Map[Char, Int][0m
[0m[[0m[31merror[0m] [0m[0m[31m  |[0m      B := Map[Char, Int][0m
[0m[[0m[31merror[0m] [0m[0m[31m  |[0m      V1 >: Int[0m
[0m[[0m[31merror[0m] [0m[0m[31m  |[0m      V1 := Int[0m
[0m[[0m[31merror[0m] [0m[0m[31m  |[0m  ordering:[0m
[0m[[0m[31merror[0m] [0m[0m[31m  |[0m  co-deps:[0m
[0m[[0m[31merror[0m] [0m[0m[31m  |[0m  contra-deps:[0m
[0m[[0m[31merror[0m] [0m[0m[31m   -----------------------------------------------------------------------------[0m[0m
[0m[[0m[31merror[0m] [0m[0m[34mExplanation[0m[0m
[0m[[0m[31merror[0m] [0m[0m[34m===========[0m[0m
[0m[[0m[31merror[0m] [0m[0m[0m
[0m[[0m[31merror[0m] [0m[0mTree: _$9[0m
[0m[[0m[31merror[0m] [0m[0mI tried to show that[0m
[0m[[0m[31merror[0m] [0m[0m  (_$9 : Map[Char, Int])[0m
[0m[[0m[31merror[0m] [0m[0mconforms to[0m
[0m[[0m[31merror[0m] [0m[0m  (Char, Int)[0m
[0m[[0m[31merror[0m] [0m[0mbut the comparison trace ended with `false`:[0m
[0m[[0m[31merror[0m] [0m[0m[0m
[0m[[0m[31merror[0m] [0m[0m  ==> (_$9 : Map[Char, Int])  <:  (Char, Int)[0m
[0m[[0m[31merror[0m] [0m[0m    ==> (_$9 : Map[Char, Int])  <:  (Char, Int)[0m
[0m[[0m[31merror[0m] [0m[0m      ==> Map[Char, Int]  <:  (Char, Int) (left is approximated)[0m
[0m[[0m[31merror[0m] [0m[0m      <== Map[Char, Int]  <:  (Char, Int) (left is approximated) = false[0m
[0m[[0m[31merror[0m] [0m[0m    <== (_$9 : Map[Char, Int])  <:  (Char, Int) = false[0m
[0m[[0m[31merror[0m] [0m[0m    ==> Map[Char, Int]  <:  (Char, Int) (left is approximated)[0m
[0m[[0m[31merror[0m] [0m[0m      ==> Map[Char, Int]  <:  (Char, Int) (left is approximated)[0m
[0m[[0m[31merror[0m] [0m[0m      <== Map[Char, Int]  <:  (Char, Int) (left is approximated) = false[0m
[0m[[0m[31merror[0m] [0m[0m    <== Map[Char, Int]  <:  (Char, Int) (left is approximated) = false[0m
[0m[[0m[31merror[0m] [0m[0m  <== (_$9 : Map[Char, Int])  <:  (Char, Int) = false[0m
[0m[[0m[31merror[0m] [0m[0m[0m
[0m[[0m[31merror[0m] [0m[0mThe tests were made under a constraint with:[0m
[0m[[0m[31merror[0m] [0m[0m uninstantiated variables: B, V1[0m
[0m[[0m[31merror[0m] [0m[0m constrained types:[0m
[0m[[0m[31merror[0m] [0m[0m  [K, B](key: Char => K)(f: Char => B)(reduce: (B, B) => B): Map[K, B],[0m
[0m[[0m[31merror[0m] [0m[0m  [B >: Map[Char, Int]](op: (B, B) => B): B,[0m
[0m[[0m[31merror[0m] [0m[0m  [B >: Map[Char, Int]](op: (B, B) => B): B,[0m
[0m[[0m[31merror[0m] [0m[0m  [V1 >: Int][0m
[0m[[0m[31merror[0m] [0m[0m    (elem1: (Char, V1), elem2: (Char, V1), elems: (Char, V1)*): Map[Char, V1],[0m
[0m[[0m[31merror[0m] [0m[0m  [V1 >: Int](kv: (Char, V1)): Map[Char, V1][0m
[0m[[0m[31merror[0m] [0m[0m bounds:[0m
[0m[[0m[31merror[0m] [0m[0m     K := Char[0m
[0m[[0m[31merror[0m] [0m[0m     B := Int[0m
[0m[[0m[31merror[0m] [0m[0m     B >: Map[Char, Int][0m
[0m[[0m[31merror[0m] [0m[0m     B := Map[Char, Int][0m
[0m[[0m[31merror[0m] [0m[0m     V1 >: Int[0m
[0m[[0m[31merror[0m] [0m[0m     V1 := Int[0m
[0m[[0m[31merror[0m] [0m[0m ordering:[0m
[0m[[0m[31merror[0m] [0m[0m co-deps:[0m
[0m[[0m[31merror[0m] [0m[0m contra-deps:[0m
[0m[[0m[31merror[0m] [0m[0mone error found[0m
[0m[[0m[31merror[0m] [0m[0m(Compile / [31mcompileIncremental[0m) Compilation failed[0m
[0m[[0m[31merror[0m] [0m[0mTotal time: 1 s, completed Nov 22, 2024, 11:45:11â€¯AM[0m
[0m[[0m[0mdebug[0m] [0m[0m> Exec(shell, None, None)[0m
[0m[[0m[0minfo[0m] [0m[0mshutting down sbt server[0m
